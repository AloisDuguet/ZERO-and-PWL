35:  Utils::appendSave(this->Q, filename, std::string("MP_Param::Q"), false);
36:  Utils::appendSave(this->getA(true), filename, std::string("MP_Param::A"), false);
37:  Utils::appendSave(this->getB(true), filename, std::string("MP_Param::B"), false);
38:  Utils::appendSave(this->C, filename, std::string("MP_Param::C"), false);
39:  Utils::appendSave(this->getb(true), filename, std::string("MP_Param::b"), false);
40:  Utils::appendSave(this->c, filename, std::string("MP_Param::c"), false);
41:  arma::sp_mat BO(this->numVars, 2);
42:  for (unsigned int i = 0; i < this->numVars; ++i) {
43:	 BO.at(i, 0) = this->Bounds.at(i).first;
44:	 BO.at(i, 1) = this->Bounds.at(i).second;
76:		this->Bounds.push_back(
82:		this->Bounds.push_back({0, GRB_INFINITY});
85:  this->set(Q_in, C_in, A_in, B_in, c_in, b_in);
100:  int startingVars = this->numVars;
101:  this->numParams += pars;
102:  this->numVars += vars;
104:	 Q = Utils::resizePatch(Q, this->numVars, this->numVars);
105:	 B = Utils::resizePatch(B, this->numConstr, this->numVars);
106:	 c = Utils::resizePatch(c, this->numVars);
111:	 B_bounds = Utils::resizePatch(B_bounds, B_bounds.n_rows + vars, this->numVars);
114:		this->Bounds.push_back({0, GRB_INFINITY});
122:		A = Utils::resizePatch(A, this->numConstr, this->numParams);
124:		C = Utils::resizePatch(C, this->numVars, this->numParams);
129:		  A = arma::join_rows(arma::zeros<arma::sp_mat>(this->numConstr, pars), A);
131:		  A.zeros(this->numConstr, pars + A.n_cols);
134:		C = Utils::resizePatch(C, this->numVars, C.n_cols);
135:		C = arma::join_rows(arma::zeros<arma::sp_mat>(this->numVars, pars), C);
143:											arma::zeros<arma::sp_mat>(this->numConstr, pars));
145:		  A.zeros(this->numConstr, pars + A.n_cols);
154:		C = Utils::resizePatch(C, this->numVars, C.n_cols);
156:			 arma::join_rows(C.cols(0, position - 1), arma::zeros<arma::sp_mat>(this->numVars, pars));
177:  unsigned int nConstr = this->b.size();
183:  double diff = double(this->B.n_cols) - this->Bounds.size();
186:	 this->Bounds.push_back({0, GRB_INFINITY});
291:  int boundSize = this->Bounds.size();
292:  // assert(boundSize == this->numVars);
300:	 auto bound = this->Bounds.at(i);
331:  this->B_bounds.zeros(nLB + nUB, boundSize);
332:  this->b_bounds.zeros(nLB + nUB);
334:  this->B_bounds.submat(0, 0, nUB - 1, boundSize - 1)         = UB;
335:  this->b_bounds.subvec(0, nUB - 1)                           = rUB;
336:  this->B_bounds.submat(nUB, 0, nLB + nUB - 1, boundSize - 1) = LB;
337:  this->b_bounds.subvec(nUB, nLB + nUB - 1)                   = rLB;
339:  ZEROAssert(this->b_bounds.size() == this->B_bounds.n_rows);
353:	 this->numVars = this->c.size();
355:	 this->numVars = this->Q.n_rows;
356:  this->numParams = this->C.n_cols;
357:  this->numConstr = this->b.size();
358:  return this->numVars;
377:  this->Q = (Q_in);
378:  this->C = (C_in);
379:  this->A = (A_in);
380:  this->B = (B_in);
381:  this->c = (c_in);
382:  this->b = (b_in);
406:  this->Q = std::move(Q_in);
407:  this->C = std::move(C_in);
408:  this->A = std::move(A_in);
409:  this->B = std::move(B_in);
410:  this->c = std::move(c_in);
411:  this->b = std::move(b_in);
424:  return this->set(obj.Q, obj.C, cons.A, cons.B, obj.c, cons.b);
434:  return this->set(std::move(obj.Q),
451:		if (!this->Q.is_symmetric() && this->Q.n_rows > 0) {
456:	 if (this->Q.n_cols > 0 && this->Q.n_cols != numVars) {
461:  if (!this->A.is_empty() && this->A.n_cols != numParams) {
465:  if (!this->A.is_empty() && this->A.n_rows != numConstr) {
469:  if (this->B.n_cols != numVars) {
473:  if (this->B.n_rows != numConstr) {
477:  if (this->B_bounds.n_rows != b_bounds.size()) {
481:  if (this->C.n_rows != numVars) {
485:  if (this->c.size() != numVars) {
503:  this->detectBounds();
504:  this->rewriteBounds();
505:  this->size();
506:  return this->dataCheck();
514:  if (!this->dataCheck())
534:  ZEROAssert(y.n_rows == this->getNumVars());
535:  ZEROAssert(x.n_rows == this->getNumParams());
537:	 this->isFeasible(y, x, tol);
568:	 return this->b;
570:	 return arma::join_cols(this->b, this->b_bounds);
582:	 return this->B;
584:	 return arma::join_cols(this->B, this->B_bounds);
596:	 return this->A;
598:	 return arma::join_cols(this->A,
599:									arma::zeros<arma::sp_mat>(this->B_bounds.n_rows, this->A.n_cols));
