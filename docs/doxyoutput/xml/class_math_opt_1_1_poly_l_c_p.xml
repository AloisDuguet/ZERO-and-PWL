<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.16">
  <compounddef id="class_math_opt_1_1_poly_l_c_p" kind="class" language="C++" prot="public">
    <compoundname>MathOpt::PolyLCP</compoundname>
    <basecompoundref refid="class_math_opt_1_1_l_c_p" prot="public" virt="non-virtual">MathOpt::LCP</basecompoundref>
    <includes refid="poly__lcp_8h" local="no">poly_lcp.h</includes>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="class_math_opt_1_1_poly_l_c_p_1a687fa5b9af020a7bdbad9afedad26d51" prot="private" static="no" mutable="no">
        <type>unsigned int</type>
        <definition>unsigned int MathOpt::PolyLCP::FeasiblePolyhedra</definition>
        <argsstring></argsstring>
        <name>FeasiblePolyhedra</name>
        <initializer>{0}</initializer>
        <briefdescription>
<para>Inheritor Class to handle the polyhedral aspects of the <ref refid="class_math_opt_1_1_l_c_p" kindref="compound">LCP</ref> class, and support algorithms. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="32" column="15" bodyfile="include/mathopt/lcp/poly_lcp.h" bodystart="32" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_math_opt_1_1_poly_l_c_p_1af3a1691f40196980cb8ee61a6e0d91af" prot="private" static="no" mutable="no">
        <type>unsigned int</type>
        <definition>unsigned int MathOpt::PolyLCP::SequentialPolyCounter</definition>
        <argsstring></argsstring>
        <name>SequentialPolyCounter</name>
        <initializer>{0}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="33" column="15" bodyfile="include/mathopt/lcp/poly_lcp.h" bodystart="33" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_math_opt_1_1_poly_l_c_p_1ab43383118b5bcce85fb3f828361bd545" prot="private" static="no" mutable="no">
        <type>long int</type>
        <definition>long int MathOpt::PolyLCP::ReverseSequentialPolyCounter</definition>
        <argsstring></argsstring>
        <name>ReverseSequentialPolyCounter</name>
        <initializer>{0}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="34" column="15" bodyfile="include/mathopt/lcp/poly_lcp.h" bodystart="34" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_math_opt_1_1_poly_l_c_p_1a41bf2044b6ad68197af7e99828272b65" prot="private" static="no" mutable="no">
        <type>std::set&lt; unsigned long int &gt;</type>
        <definition>std::set&lt;unsigned long int&gt; MathOpt::PolyLCP::AllPolyhedra</definition>
        <argsstring></argsstring>
        <name>AllPolyhedra</name>
        <initializer>=
		  {}</initializer>
        <briefdescription>
<para><ref refid="class_math_opt_1_1_l_c_p" kindref="compound">LCP</ref> feasible region is a union of polyhedra. Keeps track which of those inequalities are fixed to equality to get the individual polyhedra. </para>
        </briefdescription>
        <detaileddescription>
<para>Decimal encoding of polyhedra that have been enumerated </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="37" column="11" bodyfile="include/mathopt/lcp/poly_lcp.h" bodystart="37" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_math_opt_1_1_poly_l_c_p_1ad962f5694ca99925cb511c87e3a18304" prot="private" static="no" mutable="no">
        <type>std::set&lt; unsigned long int &gt;</type>
        <definition>std::set&lt;unsigned long int&gt; MathOpt::PolyLCP::FeasiblePoly</definition>
        <argsstring></argsstring>
        <name>FeasiblePoly</name>
        <initializer>=
		  {}</initializer>
        <briefdescription>
<para>Decimal encoding of polyhedra that have been enumerated. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="39" column="11" bodyfile="include/mathopt/lcp/poly_lcp.h" bodystart="39" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_math_opt_1_1_poly_l_c_p_1a7122e88a2136476d1985e612aea1a08d" prot="private" static="no" mutable="no">
        <type>std::set&lt; unsigned long int &gt;</type>
        <definition>std::set&lt;unsigned long int&gt; MathOpt::PolyLCP::InfeasiblePoly</definition>
        <argsstring></argsstring>
        <name>InfeasiblePoly</name>
        <initializer>=
		  {}</initializer>
        <briefdescription>
<para>Decimal encoding of polyhedra known to be infeasible. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="41" column="11" bodyfile="include/mathopt/lcp/poly_lcp.h" bodystart="41" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="class_math_opt_1_1_poly_l_c_p_1ac1da99adac1bc2319d98469d4b7a6095" prot="private" static="no" mutable="no">
        <type>unsigned long int</type>
        <definition>unsigned long int MathOpt::PolyLCP::MaxTheoreticalPoly</definition>
        <argsstring></argsstring>
        <name>MaxTheoreticalPoly</name>
        <initializer>{0}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="43" column="20" bodyfile="include/mathopt/lcp/poly_lcp.h" bodystart="43" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-attrib">
      <memberdef kind="variable" id="class_math_opt_1_1_poly_l_c_p_1a311ae5d83b9b32f2248574e9bbfbefe4" prot="public" static="no" mutable="no">
        <type>long int</type>
        <definition>long int MathOpt::PolyLCP::AddPolyMethodSeed</definition>
        <argsstring></argsstring>
        <name>AddPolyMethodSeed</name>
        <initializer>= {
		  -1}</initializer>
        <briefdescription>
<para>Seeds the Random generator for the Random polyhedra selection. Should be a positive value. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="70" column="11" bodyfile="include/mathopt/lcp/poly_lcp.h" bodystart="70" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1a963f8d9de472745b2b84f9fd2fdc488c" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void MathOpt::PolyLCP::initializeNotProcessed</definition>
        <argsstring>()</argsstring>
        <name>initializeNotProcessed</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="44" column="20" bodyfile="include/mathopt/lcp/poly_lcp.h" bodystart="44" bodyend="50"/>
      </memberdef>
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1a639732691310aa030aba6df57d6db05b" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool MathOpt::PolyLCP::addPolyFromEncoding</definition>
        <argsstring>(std::vector&lt; short int &gt; encoding, bool checkFeas=false, bool custom=false, spmat_Vec *custAi={}, vec_Vec *custbi={})</argsstring>
        <name>addPolyFromEncoding</name>
        <param>
          <type>std::vector&lt; short int &gt;</type>
          <declname>encoding</declname>
          <briefdescription><para>A vector of +1 and -1 referring to which equations and variables are taking 0 value. </para>
</briefdescription>
        </param>
        <param>
          <type>bool</type>
          <declname>checkFeas</declname>
          <defval>false</defval>
          <briefdescription><para>The polyhedron is added after ensuring feasibility, if this is true </para>
</briefdescription>
        </param>
        <param>
          <type>bool</type>
          <declname>custom</declname>
          <defval>false</defval>
          <briefdescription><para>Should the polyhedra be pushed into a custom vector of polyhedra as opposed to <ref refid="class_math_opt_1_1_l_c_p_1af19b7809bfaf15311371d9a7ce3b9a9e" kindref="member">LCP::Ai</ref> and <ref refid="class_math_opt_1_1_l_c_p_1a5b68d054b67aab64a123395ec12f4ba8" kindref="member">LCP::bi</ref> </para>
</briefdescription>
        </param>
        <param>
          <type><ref refid="zero_8h_1a47898f11e7a4b7433acbc77588a0dc03" kindref="member">spmat_Vec</ref> *</type>
          <declname>custAi</declname>
          <defval>{}</defval>
          <briefdescription><para>If custom polyhedra vector is used, pointer to vector of LHS constraint matrix </para>
</briefdescription>
        </param>
        <param>
          <type><ref refid="zero_8h_1a8d8c882d060c4d307810fdf04a6314c6" kindref="member">vec_Vec</ref> *</type>
          <declname>custbi</declname>
          <defval>{}</defval>
          <briefdescription><para>If custom polyhedra vector is used, pointer to vector of RHS of constraints </para>
</briefdescription>
        </param>
        <briefdescription>
<para>Computes the equation of the feasibility polyhedron corresponding to the given <computeroutput>encoding</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>The computed polyhedron is always pushed into a vector of <computeroutput>arma::sp_mat</computeroutput> and <computeroutput>arma::vec</computeroutput> If <computeroutput>custom</computeroutput> is false, this is the internal attribute of <ref refid="class_math_opt_1_1_l_c_p" kindref="compound">LCP</ref>, which are <ref refid="class_math_opt_1_1_l_c_p_1af19b7809bfaf15311371d9a7ce3b9a9e" kindref="member">LCP::Ai</ref> and <ref refid="class_math_opt_1_1_l_c_p_1a5b68d054b67aab64a123395ec12f4ba8" kindref="member">LCP::bi</ref>. Otherwise, the vectors can be provided as arguments. <computeroutput>true</computeroutput> value to <computeroutput>checkFeas</computeroutput> ensures that the polyhedron is pushed <emphasis>only</emphasis> if it is feasible. <simplesect kind="return"><para><computeroutput>true</computeroutput> if successfully added, else false </para>
</simplesect>
<simplesect kind="warning"><para>Does not entertain 0 in the elements of *encoding. Only +1/-1 are allowed to not encounter undefined behavior. As a result, not meant for high level code. Instead use LCP::addPoliesFromEncoding. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="51" column="20" bodyfile="src/mathopt/lcp/poly_lcp.cpp" bodystart="109" bodyend="190"/>
      </memberdef>
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1aa8450eefba5e3314531da61c24834981" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="class_math_opt_1_1_poly_l_c_p" kindref="compound">PolyLCP</ref> &amp;</type>
        <definition>MathOpt::PolyLCP &amp; MathOpt::PolyLCP::addPoliesFromEncoding</definition>
        <argsstring>(std::vector&lt; short int &gt; encoding, bool checkFeas=false, bool custom=false, spmat_Vec *custAi={}, vec_Vec *custbi={})</argsstring>
        <name>addPoliesFromEncoding</name>
        <param>
          <type>std::vector&lt; short int &gt;</type>
          <declname>encoding</declname>
          <briefdescription><para>A vector of +1, 0 and -1 referring to which equations and variables are taking 0 value. </para>
</briefdescription>
        </param>
        <param>
          <type>bool</type>
          <declname>checkFeas</declname>
          <defval>false</defval>
          <briefdescription><para>The polyhedron is added after ensuring feasibility, if this is true </para>
</briefdescription>
        </param>
        <param>
          <type>bool</type>
          <declname>custom</declname>
          <defval>false</defval>
          <briefdescription><para>Should the polyhedra be pushed into a custom vector of polyhedra as opposed to <ref refid="class_math_opt_1_1_l_c_p_1af19b7809bfaf15311371d9a7ce3b9a9e" kindref="member">LCP::Ai</ref> and <ref refid="class_math_opt_1_1_l_c_p_1a5b68d054b67aab64a123395ec12f4ba8" kindref="member">LCP::bi</ref> </para>
</briefdescription>
        </param>
        <param>
          <type><ref refid="zero_8h_1a47898f11e7a4b7433acbc77588a0dc03" kindref="member">spmat_Vec</ref> *</type>
          <declname>custAi</declname>
          <defval>{}</defval>
          <briefdescription><para>If custom polyhedra vector is used, pointer to vector of LHS constraint matrix </para>
</briefdescription>
        </param>
        <param>
          <type><ref refid="zero_8h_1a8d8c882d060c4d307810fdf04a6314c6" kindref="member">vec_Vec</ref> *</type>
          <declname>custbi</declname>
          <defval>{}</defval>
          <briefdescription><para>If custom polyhedra vector is used, pointer to vector of RHS of constraints </para>
</briefdescription>
        </param>
        <briefdescription>
<para>Computes the equation of the feasibility polyhedron corresponding to the given <computeroutput>encoding</computeroutput>. </para>
        </briefdescription>
        <detaileddescription>
<para>The computed polyhedron are always pushed into a vector of <computeroutput>arma::sp_mat</computeroutput> and <computeroutput>arma::vec</computeroutput> If <computeroutput>custom</computeroutput> is false, this is the internal attribute of <ref refid="class_math_opt_1_1_l_c_p" kindref="compound">LCP</ref>, which are <ref refid="class_math_opt_1_1_l_c_p_1af19b7809bfaf15311371d9a7ce3b9a9e" kindref="member">LCP::Ai</ref> and <ref refid="class_math_opt_1_1_l_c_p_1a5b68d054b67aab64a123395ec12f4ba8" kindref="member">LCP::bi</ref>. Otherwise, the vectors can be provided as arguments. <computeroutput>true</computeroutput> value to <computeroutput>checkFeas</computeroutput> ensures that <emphasis>each</emphasis> polyhedron that is pushed is feasible. not meant for high level code. Instead use LCP::addPoliesFromEncoding. <simplesect kind="note"><para>A value of 0 in <computeroutput>*encoding</computeroutput> implies that polyhedron corresponding to fixing the corresponding variable as well as the equation become candidates to pushed into the vector. Hence this is preferred over LCP::addPolyFromEncoding for high-level usage. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="56" column="19" bodyfile="src/mathopt/lcp/poly_lcp.cpp" bodystart="192" bodyend="237"/>
      </memberdef>
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1a33ac36a0429a514f29ef878cc0d4ce41" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>unsigned long int</type>
        <definition>unsigned long int MathOpt::PolyLCP::getNextPoly</definition>
        <argsstring>(Data::LCP::PolyhedraStrategy method)</argsstring>
        <name>getNextPoly</name>
        <param>
          <type><ref refid="namespace_data_1_1_l_c_p_1aa8773225c810ac45575f86ac803105ab" kindref="member">Data::LCP::PolyhedraStrategy</ref></type>
          <declname>method</declname>
          <briefdescription><para>The method used to add the next polyedron </para>
</briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
<para>Returns a polyhedron (in its decimal encoding) that is neither already known to be infeasible, nor already added in the inner approximation representation.</para>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="61" column="20" bodyfile="src/mathopt/lcp/poly_lcp.cpp" bodystart="239" bodyend="290"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1a99a436649fd0660fc858b13eab382366" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>MathOpt::PolyLCP::PolyLCP</definition>
        <argsstring>(GRBEnv *env, const Game::NashGame &amp;N)</argsstring>
        <name>PolyLCP</name>
        <param>
          <type>GRBEnv *</type>
          <declname>env</declname>
        </param>
        <param>
          <type>const <ref refid="class_game_1_1_nash_game" kindref="compound">Game::NashGame</ref> &amp;</type>
          <declname>N</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="64" column="2" bodyfile="include/mathopt/lcp/poly_lcp.h" bodystart="64" bodyend="69"/>
      </memberdef>
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1a32a725d75b2cd80d2216b8205134034f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>unsigned long</type>
        <definition>unsigned long MathOpt::PolyLCP::convNumPoly</definition>
        <argsstring>() const</argsstring>
        <name>convNumPoly</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
<para>To be used in interaction with <ref refid="class_math_opt_1_1_l_c_p_1a0b54da5cf1c56c79ae2addf5742aea81" kindref="member">MathOpt::LCP::convexHull</ref>. Gives the number of polyhedra in the current inner approximation of the <ref refid="class_math_opt_1_1_l_c_p" kindref="compound">LCP</ref> feasible region.</para>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="74" column="16" bodyfile="src/mathopt/lcp/poly_lcp.cpp" bodystart="397" bodyend="404"/>
      </memberdef>
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1ad40f1aa516b67c372228e81a5ec10c3f" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>unsigned int</type>
        <definition>unsigned int MathOpt::PolyLCP::convPolyPosition</definition>
        <argsstring>(unsigned long int i) const</argsstring>
        <name>convPolyPosition</name>
        <param>
          <type>unsigned long int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
<para>For the convex hull of the <ref refid="class_math_opt_1_1_l_c_p" kindref="compound">LCP</ref> feasible region computed, a bunch of variables are added for extended formulation and the added variables c</para>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="75" column="16" bodyfile="src/mathopt/lcp/poly_lcp.cpp" bodystart="406" bodyend="417"/>
      </memberdef>
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1ac72e99768d37fafac502070c3a9a39d4" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>unsigned int</type>
        <definition>unsigned int MathOpt::PolyLCP::convPolyWeight</definition>
        <argsstring>(unsigned long int i) const</argsstring>
        <name>convPolyWeight</name>
        <param>
          <type>unsigned long int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
<para>To be used in interaction with <ref refid="class_math_opt_1_1_l_c_p_1a0b54da5cf1c56c79ae2addf5742aea81" kindref="member">MathOpt::LCP::convexHull</ref>. Gives the position of the variable, which assigns the convex weight to the i-th polyhedron.</para>
<para>However, if the inner approximation has exactly one polyhedron, then returns 0.</para>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="76" column="16" bodyfile="src/mathopt/lcp/poly_lcp.cpp" bodystart="419" bodyend="438"/>
      </memberdef>
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1abf2bd458140e65f2f94392723a83f045" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>std::set&lt; unsigned long int &gt;</type>
        <definition>std::set&lt;unsigned long int&gt; MathOpt::PolyLCP::getAllPolyhedra</definition>
        <argsstring>() const</argsstring>
        <name>getAllPolyhedra</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="78" column="11" bodyfile="include/mathopt/lcp/poly_lcp.h" bodystart="78" bodyend="78"/>
      </memberdef>
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1a39ba37c8309a30307965c1caee642cdc" prot="public" static="no" const="yes" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <type>unsigned long int</type>
        <definition>unsigned long int MathOpt::PolyLCP::getNumTheoreticalPoly</definition>
        <argsstring>() const noexcept</argsstring>
        <name>getNumTheoreticalPoly</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="79" column="20" bodyfile="include/mathopt/lcp/poly_lcp.h" bodystart="79" bodyend="79"/>
      </memberdef>
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1a1f2925288011d11c496cfa5b737dfa0b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::set&lt; std::vector&lt; short int &gt; &gt;</type>
        <definition>std::set&lt; std::vector&lt; short int &gt; &gt; MathOpt::PolyLCP::addAPoly</definition>
        <argsstring>(unsigned long int nPoly=1, Data::LCP::PolyhedraStrategy method=Data::LCP::PolyhedraStrategy::Sequential, std::set&lt; std::vector&lt; short int &gt;&gt; polyhedra={})</argsstring>
        <name>addAPoly</name>
        <param>
          <type>unsigned long int</type>
          <declname>nPoly</declname>
          <defval>1</defval>
        </param>
        <param>
          <type><ref refid="namespace_data_1_1_l_c_p_1aa8773225c810ac45575f86ac803105ab" kindref="member">Data::LCP::PolyhedraStrategy</ref></type>
          <declname>method</declname>
          <defval><ref refid="namespace_data_1_1_l_c_p_1aa8773225c810ac45575f86ac803105abaa7e82daa7280af25afbaa076ac16eb1e" kindref="member">Data::LCP::PolyhedraStrategy::Sequential</ref></defval>
        </param>
        <param>
          <type>std::set&lt; std::vector&lt; short int &gt;&gt;</type>
          <declname>polyhedra</declname>
          <defval>{}</defval>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
<para>Tries to add at most <computeroutput>nPoly</computeroutput> number of polyhedra to the inner approximation representation of the current <ref refid="class_math_opt_1_1_l_c_p" kindref="compound">LCP</ref>. The set of added polyhedra (+1/-1 encoding) is appended to <computeroutput>polyhedra</computeroutput> and returned. The only reason fewer polyhedra might be added is that the fewer polyhedra already represent the feasible region of the <ref refid="class_math_opt_1_1_l_c_p" kindref="compound">LCP</ref>. <computeroutput>method</computeroutput> is casted from MathOpt::EPEC::EPECAddPolyMethod</para>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="81" column="1" bodyfile="src/mathopt/lcp/poly_lcp.cpp" bodystart="293" bodyend="342"/>
      </memberdef>
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1a93bf0c8c5905b7fd14918342fcf3e004" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool MathOpt::PolyLCP::addThePoly</definition>
        <argsstring>(const unsigned long int &amp;decimalEncoding)</argsstring>
        <name>addThePoly</name>
        <param>
          <type>const unsigned long int &amp;</type>
          <declname>decimalEncoding</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="84" column="7" bodyfile="src/mathopt/lcp/poly_lcp.cpp" bodystart="343" bodyend="353"/>
      </memberdef>
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1a238df41fff2985429a7515b0759d07af" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool MathOpt::PolyLCP::checkPolyFeas</definition>
        <argsstring>(const unsigned long int &amp;decimalEncoding)</argsstring>
        <name>checkPolyFeas</name>
        <param>
          <type>const unsigned long int &amp;</type>
          <declname>decimalEncoding</declname>
          <briefdescription><para>Decimal encoding for the polyhedron </para>
</briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="85" column="7" bodyfile="src/mathopt/lcp/poly_lcp.cpp" bodystart="440" bodyend="444"/>
      </memberdef>
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1a570be5109ab1098adebdcba2edc77d72" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool MathOpt::PolyLCP::checkPolyFeas</definition>
        <argsstring>(const std::vector&lt; short int &gt; &amp;encoding)</argsstring>
        <name>checkPolyFeas</name>
        <param>
          <type>const std::vector&lt; short int &gt; &amp;</type>
          <declname>encoding</declname>
          <briefdescription><para>A vector of +1 and -1 referring to which equations and variables are taking 0 value.) </para>
</briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
<para>Check whether the given polyhedron is or is not feasible. Given a +1/-1 encoding of a polyhedron, first checks if the polyhedron is a previously known feasible polyhedron or previously known infeasible polyhedron. If yes, returns the result appropriately. If not, solves a linear program to decide the feasibility of the given polyhedra.</para>
<para>Not <computeroutput>const</computeroutput> because it could update <ref refid="class_math_opt_1_1_poly_l_c_p_1a7122e88a2136476d1985e612aea1a08d" kindref="member">MathOpt::PolyLCP::InfeasiblePoly</ref> and <ref refid="class_math_opt_1_1_poly_l_c_p_1ad962f5694ca99925cb511c87e3a18304" kindref="member">MathOpt::PolyLCP::FeasiblePoly</ref>.</para>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="86" column="7" bodyfile="src/mathopt/lcp/poly_lcp.cpp" bodystart="446" bodyend="508"/>
      </memberdef>
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1a24f22494090ebbf1e0d66d41cfff4ba4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void MathOpt::PolyLCP::clearPolyhedra</definition>
        <argsstring>()</argsstring>
        <name>clearPolyhedra</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="87" column="7" bodyfile="include/mathopt/lcp/poly_lcp.h" bodystart="87" bodyend="91"/>
      </memberdef>
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1afc0cb20b5b7f034371acb5f7b91005c9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="class_math_opt_1_1_poly_l_c_p" kindref="compound">PolyLCP</ref> &amp;</type>
        <definition>MathOpt::PolyLCP &amp; MathOpt::PolyLCP::addPolyFromX</definition>
        <argsstring>(const arma::vec &amp;x, bool &amp;ret)</argsstring>
        <name>addPolyFromX</name>
        <param>
          <type>const arma::vec &amp;</type>
          <declname>x</declname>
        </param>
        <param>
          <type>bool &amp;</type>
          <declname>ret</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Given a <emphasis> feasible </emphasis> point <computeroutput>x</computeroutput>, checks if a polyhedron that contains <computeroutput>x</computeroutput> is already a part of this-&gt;Ai and this-&gt; bi. If it is, then this does nothing, except for printing a log message. If not, it adds a polyhedron containing this vector. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="92" column="14" bodyfile="src/mathopt/lcp/poly_lcp.cpp" bodystart="70" bodyend="107"/>
      </memberdef>
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1ae8680cc331be8b9b068038e9f49d84e1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="class_math_opt_1_1_poly_l_c_p" kindref="compound">PolyLCP</ref> &amp;</type>
        <definition>MathOpt::PolyLCP &amp; MathOpt::PolyLCP::enumerateAll</definition>
        <argsstring>(bool solveLP=true)</argsstring>
        <name>enumerateAll</name>
        <param>
          <type>bool</type>
          <declname>solveLP</declname>
          <defval>true</defval>
          <briefdescription><para>Should the polyhedra added be checked for feasibility? </para>
</briefdescription>
        </param>
        <briefdescription>
<para>Brute force computation of <ref refid="class_math_opt_1_1_l_c_p" kindref="compound">LCP</ref> feasible region. </para>
        </briefdescription>
        <detaileddescription>
<para>Computes all <formula id="30">$2^n$</formula> polyhedra defining the <ref refid="class_math_opt_1_1_l_c_p" kindref="compound">LCP</ref> feasible region. Th ese are always added to <ref refid="class_math_opt_1_1_l_c_p_1af19b7809bfaf15311371d9a7ce3b9a9e" kindref="member">LCP::Ai</ref> and <ref refid="class_math_opt_1_1_l_c_p_1a5b68d054b67aab64a123395ec12f4ba8" kindref="member">LCP::bi</ref> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="93" column="14" bodyfile="src/mathopt/lcp/poly_lcp.cpp" bodystart="355" bodyend="379"/>
      </memberdef>
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1aaa14174641821a6951ab8fcd8193a37e" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>std::string</type>
        <definition>std::string MathOpt::PolyLCP::feasabilityDetailString</definition>
        <argsstring>() const</argsstring>
        <name>feasabilityDetailString</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
<para>Returns a string that has the decimal encoding of all polyhedra which are part of <ref refid="class_math_opt_1_1_poly_l_c_p_1a41bf2044b6ad68197af7e99828272b65" kindref="member">MathOpt::PolyLCP::AllPolyhedra</ref></para>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="94" column="15" bodyfile="src/mathopt/lcp/poly_lcp.cpp" bodystart="381" bodyend="395"/>
      </memberdef>
      <memberdef kind="function" id="class_math_opt_1_1_poly_l_c_p_1a7d4e45b2d94615e9ed571b7238437713" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>unsigned int</type>
        <definition>unsigned int MathOpt::PolyLCP::getFeasiblePolyhedra</definition>
        <argsstring>() const</argsstring>
        <name>getFeasiblePolyhedra</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/lcp/poly_lcp.h" line="95" column="15" bodyfile="include/mathopt/lcp/poly_lcp.h" bodystart="95" bodyend="95"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <inheritancegraph>
      <node id="2">
        <label>MathOpt::LCP</label>
        <link refid="class_math_opt_1_1_l_c_p"/>
      </node>
      <node id="1">
        <label>MathOpt::PolyLCP</label>
        <link refid="class_math_opt_1_1_poly_l_c_p"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="2">
        <label>MathOpt::LCP</label>
        <link refid="class_math_opt_1_1_l_c_p"/>
      </node>
      <node id="1">
        <label>MathOpt::PolyLCP</label>
        <link refid="class_math_opt_1_1_poly_l_c_p"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
    </collaborationgraph>
    <location file="include/mathopt/lcp/poly_lcp.h" line="24" column="27" bodyfile="include/mathopt/lcp/poly_lcp.h" bodystart="24" bodyend="96"/>
    <listofallmembers>
      <member refid="class_math_opt_1_1_l_c_p_1ab0e3f41a96438e66929d6d1846d81cd3" prot="protected" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>_A</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a6d68d41581d8d52c72fc0e078d11cd4d" prot="protected" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>_b</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1a1f2925288011d11c496cfa5b737dfa0b" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>addAPoly</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1abb3d2bcb70270704f7b96cd406d681e2" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>addCustomCuts</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1aa8450eefba5e3314531da61c24834981" prot="private" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>addPoliesFromEncoding</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1a639732691310aa030aba6df57d6db05b" prot="private" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>addPolyFromEncoding</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1afc0cb20b5b7f034371acb5f7b91005c9" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>addPolyFromX</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1a311ae5d83b9b32f2248574e9bbfbefe4" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>AddPolyMethodSeed</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1a93bf0c8c5905b7fd14918342fcf3e004" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>addThePoly</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1af19b7809bfaf15311371d9a7ce3b9a9e" prot="protected" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>Ai</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1a41bf2044b6ad68197af7e99828272b65" prot="private" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>AllPolyhedra</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a5b68d054b67aab64a123395ec12f4ba8" prot="protected" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>bi</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a0919c037468073eacc198bc6dcc2363f" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>BigM</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1a238df41fff2985429a7515b0759d07af" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>checkPolyFeas</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1a570be5109ab1098adebdcba2edc77d72" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>checkPolyFeas</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1a24f22494090ebbf1e0d66d41cfff4ba4" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>clearPolyhedra</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a1d50200c05752a28083272b4a5b124fc" prot="protected" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>Compl</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a824d162366e30bcb729ede444f51af71" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>containCut</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a0b54da5cf1c56c79ae2addf5742aea81" prot="protected" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>convexHull</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1a32a725d75b2cd80d2216b8205134034f" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>convNumPoly</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1ad40f1aa516b67c372228e81a5ec10c3f" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>convPolyPosition</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1ac72e99768d37fafac502070c3a9a39d4" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>convPolyWeight</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1ae8680cc331be8b9b068038e9f49d84e1" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>enumerateAll</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1addeb38537d9e7cf4223fd2ba33bf72dc" prot="protected" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>Env</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a59bf18d06c235e380dc2f3a6f1419ab5" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>Eps</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a424a4d9eb7509a97d9cf4b800d957cb0" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>EpsInt</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a21b65610e8c23cbfb018d8d61ad2aa30" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>extractSols</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1aaa14174641821a6951ab8fcd8193a37e" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>feasabilityDetailString</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1ad962f5694ca99925cb511c87e3a18304" prot="private" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>FeasiblePoly</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1a687fa5b9af020a7bdbad9afedad26d51" prot="private" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>FeasiblePolyhedra</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1abf2bd458140e65f2f94392723a83f045" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>getAllPolyhedra</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a5f0cfd505da46652224d6ddf80b28a0d" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>getCompl</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1a7d4e45b2d94615e9ed571b7238437713" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>getFeasiblePolyhedra</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a8e98d36e2af38da1b66013be86b4b856" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>getLEnd</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1ab29d11d93c2bf1eead879847370fb9bd" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>getLStart</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a964119e24dee54beaacfe6bb9d5db829" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>getM</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a1d76692175585da4d03037d65a79a6d1" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>getMstar</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1a33ac36a0429a514f29ef878cc0d4ce41" prot="private" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>getNextPoly</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a6d1d8b31629fd893b90b5e246db85b65" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>getNumberLeader</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1ae30ffe7036c4bfd6d20cb400dd004b3d" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>getNumCols</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a3594c0c215a8fc483f0f611574ced3dd" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>getNumRows</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1a39ba37c8309a30307965c1caee642cdc" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>getNumTheoreticalPoly</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a6344bfaefa0cba43e2c6cd0293dfb710" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>getq</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a4b84d3c1a933d5fb208494f1097da4c3" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>getqstar</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1a7122e88a2136476d1985e612aea1a08d" prot="private" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>InfeasiblePoly</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1a963f8d9de472745b2b84f9fd2fdc488c" prot="private" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>initializeNotProcessed</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a42175395b990e8069a18963fc2666b4c" prot="protected" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>isZero</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a3c5956541410e906ce7d5c1ad844ba3e" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>LCP</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1ae15300807444d65f55acf76e632431b1" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>LCP</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1aeae3c06657dd721a859f42ef06352645" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>LCP</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1ad7a5f1af658e2be2c4a0f24000f184c7" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>LCP</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1abc0c893675e33ccab28c3f3659faaf42" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>LCP</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1ac554a16ac9497952c31b3f84d68662ff" prot="protected" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>LCPasMIP</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1ae6cc1d9683368334cc4df920b95402af" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>LCPasMIP</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1aa317c31cd870d32811b704fe6437a125" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>LCPasMIP</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1adb271830c46c32ab236961199edde62b" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>LCPasQP</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a12e4cee5104b8155fdaf499701fb36fb" prot="protected" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>LeadEnd</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1ab74625ec0c212d9d3c40ad8870741515" prot="protected" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>LeadStart</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a71496aeafa52792d00211240f51aa5ce" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>load</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a4e0d245b9c77ff47fc160df5edcfe3b5" prot="protected" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>M</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a59993bce1206d9d5dfa04c616ea572e6" prot="public" virt="virtual"><scope>MathOpt::PolyLCP</scope><name>makeQP</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1ac1da99adac1bc2319d98469d4b7a6095" prot="private" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>MaxTheoreticalPoly</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a9aef94716ce8262f55ee7c49d4398f74" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>MPECasMILP</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1ac5053d434e646ec85b9d276aedee5bcd" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>MPECasMIQP</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1ae64bd8eab0264253a226b482b1cdaa99" prot="protected" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>NumberLeader</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1a99a436649fd0660fc858b13eab382366" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>PolyLCP</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1ace92b15384c30cf9099a8b03eedb0fe0" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>print</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1ad99482b12ec46aabc831b55c28b49bbe" prot="protected" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>q</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1ab43383118b5bcce85fb3f828361bd545" prot="private" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>ReverseSequentialPolyCounter</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a8bedfd755996b18fa86121ffaabb92d0" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>save</name></member>
      <member refid="class_math_opt_1_1_poly_l_c_p_1af3a1691f40196980cb8ee61a6e0d91af" prot="private" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>SequentialPolyCounter</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1ad59aa4e9848f45e477e67eb1e273c9ef" prot="protected" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>solEncode</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a7136a8dfea61785975d36090ce3e6c01" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>solEncode</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a580e72a782e479fee8c4d8680ef8b87f" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>solEncode</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1adc9c91af096bffbfeb0ef91b20fc58bc" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>UseIndicators</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a6261825711653d2af9aacef1887384a2" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>write</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1a2d0f2ec3d8fa860d0db32402dbb22451" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>zFromX</name></member>
      <member refid="class_math_opt_1_1_l_c_p_1aba79835cd3e9ead070a2f2cc56da151a" prot="public" virt="non-virtual"><scope>MathOpt::PolyLCP</scope><name>~LCP</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
