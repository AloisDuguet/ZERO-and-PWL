<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.16">
  <compounddef id="namespace_math_opt" kind="namespace" language="C++">
    <compoundname>MathOpt</compoundname>
    <innerclass refid="class_math_opt_1_1_i_p___param" prot="public">MathOpt::IP_Param</innerclass>
    <innerclass refid="class_math_opt_1_1_l_c_p" prot="public">MathOpt::LCP</innerclass>
    <innerclass refid="class_math_opt_1_1_m_p___param" prot="public">MathOpt::MP_Param</innerclass>
    <innerclass refid="class_math_opt_1_1_outer_l_c_p" prot="public">MathOpt::OuterLCP</innerclass>
    <innerclass refid="class_math_opt_1_1_poly_l_c_p" prot="public">MathOpt::PolyLCP</innerclass>
    <innerclass refid="struct_math_opt_1_1_q_p___constraints" prot="public">MathOpt::QP_Constraints</innerclass>
    <innerclass refid="struct_math_opt_1_1_q_p___objective" prot="public">MathOpt::QP_Objective</innerclass>
    <innerclass refid="class_math_opt_1_1_q_p___param" prot="public">MathOpt::QP_Param</innerclass>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespace_math_opt_1aa0a70822f74c1fc679e018023c08905e" prot="public" static="no">
        <type>struct <ref refid="struct_math_opt_1_1_q_p___objective" kindref="compound">MathOpt::QP_Objective</ref></type>
        <definition>typedef struct MathOpt::QP_Objective  MathOpt::QP_objective</definition>
        <argsstring></argsstring>
        <name>QP_objective</name>
        <briefdescription>
<para>struct to handle the objective params of <ref refid="class_math_opt_1_1_m_p___param" kindref="compound">MP_Param</ref> and inheritors </para>
        </briefdescription>
        <detaileddescription>
<para>Refer <ref refid="class_math_opt_1_1_q_p___param" kindref="compound">QP_Param</ref> class for what Q, C and c mean. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/mathopt.h" line="31" column="16"/>
      </memberdef>
      <memberdef kind="typedef" id="namespace_math_opt_1a7077c09ae1bba23b9181ac92bf0c6dea" prot="public" static="no">
        <type>struct <ref refid="struct_math_opt_1_1_q_p___constraints" kindref="compound">MathOpt::QP_Constraints</ref></type>
        <definition>typedef struct MathOpt::QP_Constraints  MathOpt::QP_constraints</definition>
        <argsstring></argsstring>
        <name>QP_constraints</name>
        <briefdescription>
<para>struct to handle the constraint params of <ref refid="class_math_opt_1_1_m_p___param" kindref="compound">MP_Param</ref> and inheritors </para>
        </briefdescription>
        <detaileddescription>
<para>Refer <ref refid="class_math_opt_1_1_q_p___param" kindref="compound">QP_Param</ref> class for what A, B and b mean. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/mathopt.h" line="37" column="18"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespace_math_opt_1aa4eaa00160eb2098969ef087c92eea5d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>arma::vec</type>
        <definition>arma::vec MathOpt::LPSolve</definition>
        <argsstring>(const arma::sp_mat &amp;A, const arma::vec &amp;b, const arma::vec &amp;c, int &amp;status, bool positivity=false)</argsstring>
        <name>LPSolve</name>
        <param>
          <type>const arma::sp_mat &amp;</type>
          <declname>A</declname>
          <briefdescription><para>The constraint matrix </para>
</briefdescription>
        </param>
        <param>
          <type>const arma::vec &amp;</type>
          <declname>b</declname>
          <briefdescription><para>RHS of the constraint matrix </para>
</briefdescription>
        </param>
        <param>
          <type>const arma::vec &amp;</type>
          <declname>c</declname>
          <briefdescription><para>If feasible, returns a std::vector that minimizes along this direction </para>
</briefdescription>
        </param>
        <param>
          <type>int &amp;</type>
          <declname>status</declname>
          <briefdescription><para>Status of the optimization problem. If optimal, this will be GRB_OPTIMAL </para>
</briefdescription>
        </param>
        <param>
          <type>bool</type>
          <declname>positivity</declname>
          <defval>false</defval>
          <briefdescription><para>Should <formula id="33">$x\geq0$</formula> be enforced? </para>
</briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Checks if the polyhedron given by <formula id="34">$ Ax\leq b$</formula> is feasible. If yes, returns the point <formula id="35">$x$</formula> in the polyhedron that minimizes <formula id="36">$c^Tx$</formula> positivity can be enforced on the variables easily. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/mathopt.h" line="40" column="13" bodyfile="src/mathopt/mathopt.cpp" bodystart="202" bodyend="249" declfile="include/mathopt/mathopt.h" declline="40" declcolumn="13"/>
      </memberdef>
      <memberdef kind="function" id="namespace_math_opt_1a0a13d06524e3ad2baf756e15a794a745" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>unsigned int</type>
        <definition>unsigned int MathOpt::convexHull</definition>
        <argsstring>(const std::vector&lt; arma::sp_mat * &gt; *Ai, const std::vector&lt; arma::vec * &gt; *bi, arma::sp_mat &amp;A, arma::vec &amp;b, arma::sp_mat Acom={}, arma::vec bcom={})</argsstring>
        <name>convexHull</name>
        <param>
          <type>const std::vector&lt; arma::sp_mat * &gt; *</type>
          <declname>Ai</declname>
          <briefdescription><para>Inequality constraints LHS that define polyhedra whose convex hull is to be found </para>
</briefdescription>
        </param>
        <param>
          <type>const std::vector&lt; arma::vec * &gt; *</type>
          <declname>bi</declname>
          <briefdescription><para>Inequality constraints RHS that define polyhedra whose convex hull is to be found </para>
</briefdescription>
        </param>
        <param>
          <type>arma::sp_mat &amp;</type>
          <declname>A</declname>
          <briefdescription><para>Pointer to store the output of the convex hull LHS </para>
</briefdescription>
        </param>
        <param>
          <type>arma::vec &amp;</type>
          <declname>b</declname>
          <briefdescription><para>Pointer to store the output of the convex hull RHS </para>
</briefdescription>
        </param>
        <param>
          <type>arma::sp_mat</type>
          <declname>Acom</declname>
          <defval>{}</defval>
          <briefdescription><para>any common constraints to all the polyhedra - lhs. </para>
</briefdescription>
        </param>
        <param>
          <type>arma::vec</type>
          <declname>bcom</declname>
          <defval>{}</defval>
          <briefdescription><para>Any common constraints to ALL the polyhedra - RHS. </para>
</briefdescription>
        </param>
        <briefdescription>
<para>Computing convex hull of finite union of polyhedra. </para>
        </briefdescription>
        <detaileddescription>
<para>Computes the convex hull of a finite union of polyhedra where each polyhedra <formula id="31">$P_i$</formula> is of the form <formula id="32">\begin{eqnarray} A^ix &amp;\leq&amp; b^i\\ x &amp;\geq&amp; 0 \end{eqnarray}</formula> This uses Balas&apos; approach to compute the convex hull.</para>
<para><bold>Cross reference:</bold> Conforti, Michele; Cornuéjols, Gérard; and Zambelli, Giacomo. Integer programming. Vol. 271. Berlin: Springer, 2014. Refer: Eqn 4.31 </para>
        </detaileddescription>
        <inbodydescription>
<para>&lt; Perform increasingly better inner approximations in iterations</para>
        </inbodydescription>
        <location file="include/mathopt/mathopt.h" line="46" column="16" bodyfile="src/mathopt/mathopt.cpp" bodystart="19" bodyend="123" declfile="include/mathopt/mathopt.h" declline="46" declcolumn="16"/>
      </memberdef>
      <memberdef kind="function" id="namespace_math_opt_1af3d7bfcf9b11cefb7f4521d685211934" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void MathOpt::compConvSize</definition>
        <argsstring>(arma::sp_mat &amp;A, unsigned int nFinCons, unsigned int nFinVar, const std::vector&lt; arma::sp_mat * &gt; *Ai, const std::vector&lt; arma::vec * &gt; *bi, const arma::sp_mat &amp;Acom, const arma::vec &amp;bcom)</argsstring>
        <name>compConvSize</name>
        <param>
          <type>arma::sp_mat &amp;</type>
          <declname>A</declname>
          <briefdescription><para>Output parameter </para>
</briefdescription>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>nFinCons</declname>
          <briefdescription><para>Number of rows in final matrix A </para>
</briefdescription>
        </param>
        <param>
          <type>unsigned int</type>
          <declname>nFinVar</declname>
          <briefdescription><para>Number of columns in the final matrix A </para>
</briefdescription>
        </param>
        <param>
          <type>const std::vector&lt; arma::sp_mat * &gt; *</type>
          <declname>Ai</declname>
          <briefdescription><para>Inequality constraints LHS that define polyhedra whose convex hull is to be found </para>
</briefdescription>
        </param>
        <param>
          <type>const std::vector&lt; arma::vec * &gt; *</type>
          <declname>bi</declname>
          <briefdescription><para>Inequality constraints RHS that define polyhedra whose convex hull is to be found </para>
</briefdescription>
        </param>
        <param>
          <type>const arma::sp_mat &amp;</type>
          <declname>Acom</declname>
          <briefdescription><para>LHS of the common constraints for all polyhedra </para>
</briefdescription>
        </param>
        <param>
          <type>const arma::vec &amp;</type>
          <declname>bcom</declname>
          <briefdescription><para>RHS of the common constraints for all polyhedra </para>
</briefdescription>
        </param>
        <briefdescription>
<para>INTERNAL FUNCTION NOT FOR GENERAL USE. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="warning"><para>INTERNAL FUNCTION NOT FOR GENERAL USE. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/mathopt.h" line="53" column="8" bodyfile="src/mathopt/mathopt.cpp" bodystart="125" bodyend="200" declfile="include/mathopt/mathopt.h" declline="53" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="namespace_math_opt_1aabf121bcb871000488825dd64750500c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void MathOpt::getDualMembershipLP</definition>
        <argsstring>(std::unique_ptr&lt; GRBModel &gt; &amp;ConvexModel, unsigned int &amp;numV, const arma::sp_mat &amp;V, unsigned int &amp;numR, const arma::sp_mat &amp;R, const arma::vec &amp;vertex, const bool &amp;normalization)</argsstring>
        <name>getDualMembershipLP</name>
        <param>
          <type>std::unique_ptr&lt; GRBModel &gt; &amp;</type>
          <declname>ConvexModel</declname>
          <defname>convexModel</defname>
          <briefdescription><para>the model object </para>
</briefdescription>
        </param>
        <param>
          <type>unsigned int &amp;</type>
          <declname>numV</declname>
          <briefdescription><para>the number of vertices already in the model </para>
</briefdescription>
        </param>
        <param>
          <type>const arma::sp_mat &amp;</type>
          <declname>V</declname>
          <briefdescription><para>the vertices matrix </para>
</briefdescription>
        </param>
        <param>
          <type>unsigned int &amp;</type>
          <declname>numR</declname>
          <briefdescription><para>the number rays already in the model </para>
</briefdescription>
        </param>
        <param>
          <type>const arma::sp_mat &amp;</type>
          <declname>R</declname>
          <briefdescription><para>the rays matrix </para>
</briefdescription>
        </param>
        <param>
          <type>const arma::vec &amp;</type>
          <declname>vertex</declname>
          <briefdescription><para>the vertex input that needs to be verifies </para>
</briefdescription>
        </param>
        <param>
          <type>const bool &amp;</type>
          <declname>normalization</declname>
          <briefdescription><para>True if the LP is normalized (preventing unboundedness in case of feasibility) </para>
</briefdescription>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
<para>Given a vector <computeroutput>R</computeroutput> of rays, and <computeroutput>V</computeroutput> or vertices, builds a model in <computeroutput>ConvexModel</computeroutput> that certifies whether <computeroutput>vertex</computeroutput> belongs to the convex-hull generated by <computeroutput>V</computeroutput> and <computeroutput>R</computeroutput>. In case <computeroutput>numV</computeroutput> and/or <computeroutput>numR</computeroutput> are specified, it just updates the model in <computeroutput>ConvexModel</computeroutput> with the missing vertices and rays. In case <computeroutput>normalization</computeroutput> is specified, the model includes a normalization constraint.</para>
        </inbodydescription>
        <location file="include/mathopt/mathopt.h" line="61" column="8" bodyfile="src/mathopt/mathopt.cpp" bodystart="259" bodyend="376" declfile="include/mathopt/mathopt.h" declline="61" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="namespace_math_opt_1a8b4c66568c38b6a5b08a7fca9372a7dd" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>void</type>
        <definition>void MathOpt::print</definition>
        <argsstring>(const perps &amp;C) noexcept</argsstring>
        <name>print</name>
        <param>
          <type>const <ref refid="zero_8h_1ad87785d9eb3e6e48c0895b348f6660ca" kindref="member">perps</ref> &amp;</type>
          <declname>C</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/mathopt.h" line="69" column="8" bodyfile="src/mathopt/mathopt.cpp" bodystart="251" bodyend="255" declfile="include/mathopt/mathopt.h" declline="69" declcolumn="8"/>
      </memberdef>
      <memberdef kind="function" id="namespace_math_opt_1aedd7c328cf667c15244fec225b90a65d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; MathOpt::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const IP_Param &amp;I)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="class_math_opt_1_1_i_p___param" kindref="compound">IP_Param</ref> &amp;</type>
          <declname>I</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/mp_param/ip_param.h" line="28" column="3" bodyfile="src/mathopt/mp_param/ip_param.cpp" bodystart="20" bodyend="25" declfile="include/mathopt/mp_param/ip_param.h" declline="28" declcolumn="3"/>
      </memberdef>
      <memberdef kind="function" id="namespace_math_opt_1a81f3217167710fd7c3d4211658cfa5d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>std::ostream &amp;</type>
        <definition>std::ostream &amp; MathOpt::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const QP_Param &amp;Q)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type>std::ostream &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="class_math_opt_1_1_q_p___param" kindref="compound">QP_Param</ref> &amp;</type>
          <declname>Q</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="include/mathopt/mp_param/qp_param.h" line="26" column="3" bodyfile="src/mathopt/mp_param/qp_param.cpp" bodystart="20" bodyend="25" declfile="include/mathopt/mp_param/qp_param.h" declline="26" declcolumn="3"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="include/mathopt/lcp/lcp.h" line="39" column="17"/>
  </compounddef>
</doxygen>
